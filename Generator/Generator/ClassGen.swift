//
//  ClassGen.swift
//  Generator
//
//  Created by Miguel de Icaza on 3/26/23.
//

import Foundation

// Populated with the types loaded from the api.json, we assume they are all reference types
// anything else is not
var referenceTypes: [String:Bool] = [:]

// Maps a typename to its toplevel Json element
var tree: [String: JGodotExtensionAPIClass] = [:]

var typeToChildren: [String:[String]] = [:]

func generateMethods (cdef: JGodotExtensionAPIClass, methods: [JGodotClassMethod]) {
    p ("/* Methods */")
    
    for method in methods {
        let bindName = "method_\(method.name)"
        
        guard let methodHash = method.hash else {
            print ("Method with no Hash: \(cdef.name).\(method.name)")
            continue
        }
        b ("static var \(bindName): GDExtensionMethodBindPtr =", suffix: "()") {
            p ("let methodName = StringName (\"\(method.name)\")")
            
            if method.hash == nil {
                
            }
            /// TODO: make the handle in the generated bindings be an UnsafeRawPointer
            /// to avoid these casts here
            p ("return gi.classdb_get_method_bind (UnsafeRawPointer (\(cdef.name).className.handle), UnsafeRawPointer (methodName.handle), \(methodHash))!")
        }
        
        b ("func \(method.name) ()") {
            
        }
    }
}

var okList = ["Object", "RefCounted", "Node2D", "Node", "CanvasItem", "ConfigFile"]
func generateClasses (values: [JGodotExtensionAPIClass]) {
    // Assemble all the reference types, we use to test later
    for cdef in values {
        referenceTypes[cdef.name] = true
    }
    // Also a convenient hash to go from name to json
    // And track which types must be opened up
    for cdef in values {
        tree [cdef.name] = cdef
        
        let base = cdef.inherits ?? ""
        if base != "" {
            if var v = typeToChildren [cdef.name] {
                v.append(cdef.inherits ?? "")
            } else {
                typeToChildren [cdef.name] = [cdef.inherits ?? ""]
            }
        }
    }
    
    p ("// Generated by Swift code generator - do not edit\nimport Foundation\nimport GDExtension\n")
    for cdef in values {
        if !okList.contains (cdef.name) {
            print ("Skipping \(cdef.name)")
            continue
        }
        
        let typeDecl: String
        if let inherits = cdef.inherits {
            typeDecl = "open class \(cdef.name): \(inherits)"
        } else {
            typeDecl = "open class \(cdef.name)"
        }
        
        // class or extension (for Object)
        b (typeDecl) {
            p ("static private var className = StringName (\"\(cdef.name)\")")
            if cdef.inherits != nil {
                b ("public override init (nativeHandle: UnsafeRawPointer)") {
                    p("super.init (nativeHandle: nativeHandle)")
                }
            } else {
                p ("var handle: UnsafeRawPointer")
                b ("public init (nativeHandle: UnsafeRawPointer)") {
                    p ("handle = nativeHandle")
                }
            }
            if let methods = cdef.methods {
                generateMethods (cdef: cdef, methods: methods)
            }
        }
        
    }
}

class Test {
    init (_ str: String) {}
}

open class A {
    static var a = Test("b")
}

open class B {
    static var a = Test("a")
}
